<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Neural Breaker: Swarm Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; margin: 0 auto; background: #1a1a1a; box-shadow: 0 0 50px rgba(0,210,255,0.1); }
        
        /* UI 레이어 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #top-hud { padding: 30px; text-align: center; color: #fff; font-size: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        #troop-counter { font-size: 40px; color: #00d2ff; display: block; margin-top: 5px; }
        
        /* 시작 화면 */
        #start-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(10px); z-index: 10; pointer-events: auto;
        }
        h1 { color: #fff; font-size: 40px; margin: 0 0 10px 0; font-style: italic; text-transform: uppercase; letter-spacing: -2px; }
        h2 { color: #00d2ff; font-size: 18px; margin: 0 0 30px 0; font-weight: normal; letter-spacing: 5px; }
        p { color: #888; margin-bottom: 40px; font-size: 14px; }
        
        .btn-start {
            background: #00d2ff; color: #000; border: none; padding: 20px 60px;
            font-size: 24px; font-weight: 900; transform: skew(-10deg);
            cursor: pointer; box-shadow: 0 0 30px rgba(0,210,255,0.5);
            transition: all 0.1s;
        }
        .btn-start:active { transform: skew(-10deg) scale(0.95); background: #fff; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="top-hud">
        TROOP COUNT
        <span id="troop-counter">1</span>
    </div>
</div>

<div id="start-overlay">
    <h1>Neural<br>Breaker</h1>
    <h2>SWARM PROTOCOL</h2>
    <p>DRAG to Control the Swarm // Hit BLUE Gates</p>
    <button class="btn-start" onclick="initGame()">DEPLOY</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    /** * [STEP 2 IMPLEMENTATION]
     * 1. Math Gate Logic (+, -, *, /)
     * 2. Swarm Rendering (Visuals follow Count)
     * 3. Dynamic Fire Rate based on Swarm Size
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- 1. Audio System (Procedural) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let actx;
    let masterGain;

    function initAudio() {
        if (!actx) {
            actx = new AudioContext();
            masterGain = actx.createGain();
            masterGain.gain.value = 0.2;
            masterGain.connect(actx.destination);
        }
        if (actx.state === 'suspended') actx.resume();
    }

    const SFX = {
        playTone: (freq, type, duration, vol=1) => {
            if(!actx) return;
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, actx.currentTime);
            gain.gain.setValueAtTime(vol, actx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + duration);
            osc.connect(gain); gain.connect(masterGain);
            osc.start(); osc.stop(actx.currentTime + duration);
        },
        grow: () => { // 병력 증가 (청량한 소리)
            SFX.playTone(600, 'sine', 0.1);
            setTimeout(() => SFX.playTone(900, 'sine', 0.2), 50);
        },
        shrink: () => { // 병력 감소 (낮은 소리)
            SFX.playTone(150, 'sawtooth', 0.2, 0.5);
        },
        shoot: () => SFX.playTone(300 + Math.random()*100, 'square', 0.05, 0.1)
    };

    // --- 2. Game Constants & State ---
    let width, height;
    let state = 'MENU'; 
    let frame = 0;
    
    const LANE_WIDTH = 420;
    const SPEED = 10;
    
    // Player (The Swarm Anchor)
    const player = {
        x: 0, y: 0,
        targetX: 0,
        count: 1, // 실제 병력 수 (Logic)
        radius: 30 // 군집의 물리적 크기
    };

    // Camera
    const camera = { x: 0, lag: 0.08 };

    // Swarm Particles (Visuals)
    let swarmUnits = []; // {x, y, ox, oy}
    const MAX_VISUAL_UNITS = 80; // 성능을 위해 화면엔 최대 80마리만 그림

    // Objects
    let gates = [];
    let enemies = [];
    let bullets = [];
    let particles = [];
    let score = 0;

    // Input
    let isDragging = false;
    let dragStartX = 0;
    let playerStartX = 0;

    // --- 3. Setup ---
    function resize() {
        width = Math.min(window.innerWidth, 550); 
        height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        player.y = height - 180;
    }
    window.addEventListener('resize', resize);
    resize();

    function initGame() {
        document.getElementById('start-overlay').style.display = 'none';
        initAudio();
        reset();
        state = 'PLAY';
        loop();
    }

    function reset() {
        player.x = width / 2;
        player.targetX = width / 2;
        player.count = 1;
        camera.x = width / 2;
        
        gates = []; enemies = []; bullets = []; particles = []; swarmUnits = [];
        frame = 0;
        
        // 초기 유닛 생성
        updateSwarmVisuals();
    }

    // --- 4. Input Handling (Swerve) ---
    const onDown = (e) => {
        if(state !== 'PLAY') return;
        isDragging = true;
        dragStartX = e.clientX || e.touches[0].clientX;
        playerStartX = player.targetX;
    };
    const onMove = (e) => {
        if(!isDragging) return;
        const cx = e.clientX || e.touches[0].clientX;
        const diff = (cx - dragStartX) * 1.3; 
        player.targetX = Math.max(width/2 - LANE_WIDTH/2 + 20, Math.min(width/2 + LANE_WIDTH/2 - 20, playerStartX + diff));
    };
    const onUp = () => { isDragging = false; };

    canvas.addEventListener('mousedown', onDown); canvas.addEventListener('touchstart', onDown);
    window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove);
    window.addEventListener('mouseup', onUp); window.addEventListener('touchend', onUp);

    // --- 5. Core Logic ---
    
    function update() {
        // A. Movement & Camera
        player.x += (player.targetX - player.x) * 0.15;
        camera.x += (player.x - camera.x) * camera.lag;

        // B. Swarm Logic (Follow the Anchor)
        updateSwarmVisuals();
        
        // C. Spawning
        if (frame % 200 === 0) spawnGateRow();
        if (frame % 80 === 0 && frame > 100) spawnEnemy();

        // D. Shooting (Auto Fire based on Troop Count)
        // 병력이 많을수록 발사 속도가 빨라짐 (최소 5프레임, 최대 30프레임 간격)
        let fireRate = Math.floor(Math.max(5, 30 - Math.sqrt(player.count) * 2));
        if (frame % fireRate === 0) {
            spawnBullet();
        }

        updateObjects();
    }

    // --- Swarm System ---
    function updateSwarmVisuals() {
        // 목표: player.count에 맞춰 swarmUnits 배열 크기 조절
        const targetVisuals = Math.min(player.count, MAX_VISUAL_UNITS);
        
        // 1. 부족하면 채우기
        while(swarmUnits.length < targetVisuals) {
            swarmUnits.push({
                x: player.x, 
                y: player.y,
                ox: (Math.random()-0.5) * 20, // 목표 오프셋
                oy: (Math.random()-0.5) * 20
            });
        }
        // 2. 남으면 버리기
        while(swarmUnits.length > targetVisuals) {
            swarmUnits.pop();
        }

        // 3. 움직임 (Boid-like smoothing)
        // 병력이 많아질수록 더 넓게 퍼짐
        const spread = 10 + Math.sqrt(player.count) * 3; 

        swarmUnits.forEach((u, i) => {
            // 목표 위치: 앵커 위치 + 고유 오프셋 * 퍼짐 정도
            const tx = player.x + u.ox * (spread/10);
            const ty = player.y + u.oy * (spread/10);
            
            u.x += (tx - u.x) * 0.2;
            u.y += (ty - u.y) * 0.2;
        });
        
        // Update UI
        document.getElementById('troop-counter').innerText = player.count;
    }

    // --- Math Gate Logic ---
    function calculateGate(op, val) {
        let prev = player.count;
        if (op === '+') player.count += val;
        else if (op === '-') player.count = Math.max(0, player.count - val);
        else if (op === '×') player.count *= val;
        else if (op === '÷') player.count = Math.floor(player.count / val);

        if (player.count > prev) SFX.grow();
        else SFX.shrink();

        if (player.count <= 0) gameOver();
    }

    function spawnGateRow() {
        const y = -100;
        const w = LANE_WIDTH / 2 - 10;
        
        // Math Operations Generator
        const ops = [
            { op: '+', val: Math.floor(Math.random()*20)+10, type: 'good' },
            { op: '×', val: Math.floor(Math.random()*2)+2, type: 'good' },
            { op: '-', val: Math.floor(Math.random()*10)+5, type: 'bad' },
            { op: '÷', val: 2, type: 'bad' }
        ];

        // Ensure at least one is "good" or reasonable
        let leftOp = ops[Math.floor(Math.random() * 2)]; // 0,1 are good
        let rightOp = ops[Math.floor(Math.random() * 4)]; // Any

        gates.push({ x: width/2 - w - 5, y: y, w: w, h: 60, ...leftOp });
        gates.push({ x: width/2 + 5, y: y, w: w, h: 60, ...rightOp });
    }

    function spawnEnemy() {
        const w = 40;
        const hp = 5 + Math.floor(frame / 500) * 5;
        enemies.push({
            x: (width/2 - LANE_WIDTH/2) + Math.random()*(LANE_WIDTH-w),
            y: -50, w: w, h: w, hp: hp, maxHp: hp
        });
    }

    function spawnBullet() {
        // 선두 유닛 몇몇이 총을 쏨 (최대 5발 동시 발사)
        const shooters = Math.min(5, swarmUnits.length);
        for(let i=0; i<shooters; i++) {
            let u = swarmUnits[swarmUnits.length - 1 - i]; 
            if(!u) break;
            bullets.push({x: u.x, y: u.y, vx: 0, vy: -15});
        }
        SFX.shoot();
    }

    function updateObjects() {
        // Move & Logic
        [gates, enemies, bullets].forEach(arr => {
            for(let i=arr.length-1; i>=0; i--) {
                let o = arr[i];
                if(o.vx !== undefined) { o.x += o.vx; o.y += o.vy; } // Bullet
                else o.y += SPEED; // World Objects

                if(o.y > height + 100 || o.y < -200) arr.splice(i, 1);
            }
        });

        // 1. Bullet vs Enemy (Loop backwards to prevent skipping)
        for (let bIdx = bullets.length - 1; bIdx >= 0; bIdx--) {
            let b = bullets[bIdx];
            let hit = false;
            for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                let e = enemies[eIdx];
                if(Math.abs(b.x - (e.x+e.w/2)) < e.w/2 && Math.abs(b.y - e.y) < e.h) {
                    e.hp--;
                    hit = true;
                    if(e.hp <= 0) {
                        enemies.splice(eIdx, 1);
                        createParticles(e.x+e.w/2, e.y, '#f00', 10);
                    }
                    break; 
                }
            }
            if(hit) bullets.splice(bIdx, 1);
        }

        // 2. Player vs Gate
        gates.forEach((g, i) => {
            if(player.y > g.y && player.y < g.y + g.h &&
               player.x > g.x && player.x < g.x + g.w) {
                calculateGate(g.op, g.val);
                gates.splice(i, 1); // Remove trigger
                // Remove sibling gate (simple logic)
                gates = gates.filter(og => Math.abs(og.y - g.y) > 10);
                createParticles(player.x, player.y, g.type === 'good' ? '#0ff' : '#f00', 20);
            }
        });

        // 3. Player vs Enemy (Collision Damage)
        enemies.forEach((e, i) => {
            if(Math.abs(player.x - (e.x+e.w/2)) < 40 && Math.abs(player.y - e.y) < 40) {
                // 적과 부딪히면 병력 감소
                let loss = 5; 
                player.count = Math.max(0, player.count - loss);
                SFX.shrink();
                createParticles(e.x, e.y, '#fff', 5);
                enemies.splice(i, 1);
                if (player.count <= 0) gameOver();
            }
        });
        
        // Particles
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            if(p.life <= 0) particles.splice(i, 1);
        });
    }

    function createParticles(x, y, c, n) {
        for(let i=0; i<n; i++) particles.push({x, y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1, c});
    }

    function gameOver() {
        state = 'OVER';
        alert("MISSION FAILED. The swarm has been depleted.");
        reset();
        state = 'PLAY';
    }

    // --- 6. Rendering ---
    function draw() {
        ctx.clearRect(0, 0, width, height);

        // A. World Transformation (Cam)
        const offset = width/2 - camera.x;
        ctx.save();
        ctx.translate(offset, 0);

        // B. Lane
        ctx.fillStyle = '#222';
        ctx.fillRect(width/2 - LANE_WIDTH/2, 0, LANE_WIDTH, height);
        ctx.strokeStyle = '#444';
        ctx.beginPath();
        for(let i=0; i<5; i++) { // Grid lines
            let lx = width/2 - LANE_WIDTH/2 + i*(LANE_WIDTH/4);
            ctx.moveTo(lx, 0); ctx.lineTo(lx, height);
        }
        ctx.stroke();

        // C. Gates
        gates.forEach(g => {
            const isGood = g.type === 'good';
            ctx.fillStyle = isGood ? 'rgba(0, 100, 255, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            ctx.strokeStyle = isGood ? '#00d2ff' : '#ff0000';
            ctx.lineWidth = 3;
            
            // Glass panel
            ctx.fillRect(g.x, g.y, g.w, g.h);
            ctx.strokeRect(g.x, g.y, g.w, g.h);
            
            // Text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${g.op}${g.val}`, g.x + g.w/2, g.y + 40);
        });

        // D. Enemies
        enemies.forEach(e => {
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(e.x, e.y, e.w, e.h);
            // Simple HP Bar
            ctx.fillStyle = '#000'; ctx.fillRect(e.x, e.y - 10, e.w, 5);
            ctx.fillStyle = '#0f0'; ctx.fillRect(e.x, e.y - 10, e.w * (e.hp / e.maxHp), 5);
        });

        // E. Bullets
        ctx.fillStyle = '#ffeb3b';
        bullets.forEach(b => {
            ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
        });

        // F. The SWARM (Player)
        swarmUnits.forEach(u => {
            ctx.fillStyle = '#00d2ff';
            ctx.beginPath();
            // 드론 모양 (작은 사각형)
            ctx.rect(u.x - 3, u.y - 3, 6, 6);
            ctx.fill();
        });
        
        // G. Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.c;
            ctx.fillRect(p.x, p.y, 4, 4);
        });
        ctx.globalAlpha = 1;

        ctx.restore();
    }

    function loop() {
        if(state === 'PLAY') {
            update();
            draw();
            frame++;
            requestAnimationFrame(loop);
        }
    }
</script>
</body>
</html>